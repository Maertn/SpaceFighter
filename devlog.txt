2023-03-20
#01
--
Got a working setup, with a venv and a link to GitHub.
I've created a main.py where the class Game is constructed and run.
In Game we initialize pygame. We call an attribute self.screen which calls a display from pygame.
The display requires width and height, which we store in settings.py.
We also give Game a way to shut down, which is handy if you don't want to reboot the PC everytime Game is called.

We've called self.screen.fill('black'), but when testing it doesn't do anything.
Let's keep it as a placeholder for the procedures that actually display images.
We also preemptively call display.update(). 
Leaving the parameters blank makes this method redraw everything on the screen. 
It works the same as flip(), but update() doesn't support OpenGL. 
update() can take parameters that specify which surfaces are to be updated. 
update() could be used as a more efficient way to draw if certain surfaces don't have to be updated.
I'm not sure if SF will contain any surfaces that don't update, so I'm not sure if I'll be able to exploit this feature.
I'll just keep it like this for now. 
The pygame docs state that it's better to use one update() that renders a list of all the rects, instead of several update() that renders
partial lists. Guess that calling display.update() once will suffice.

Next step we'll create a player.

#2
--
I managed to draw a surface representing our player. It's a red surface of 64*64.
I've already setup a rectangle corresponding to the player.
Let's implement some movement options next.

I've chosen to stick with the layout as presented in the Zelda tutorial, where main calls a level.
Within level we take care of initializing pygame and creating the display. Everything that is to be displayed is managed from level.
Within the level is contained the call to a player, which in turn is from the Player class in player.py.
The Player inherits from the pygame class Sprite, which gives us an easy way to manage properties,
like rendering and collision, through it's groups.
The rendering is done within the level. The classes implemented in the level are to be setup in such a way that they
can be integrated to the level environment, e.g. assigning a groups parameter that allows Level to execute the class according to 
specifications per group.

#3
--
Let's make some rules regarding the process.
I'll create some challenges for each block. We're currently in the 1.level branch, because I copied the start from the Zelda tutorial.
Going by the standards of the Zelda tut I should be done with the level, since I created the structure that allows level to accept
classes.

Next step will be the player. I'll skip the skin for now. So all we need is player movement.
Regarding player I'll also want to implement an attack. The attack needs to spawn bullets.
The bullets spawned will just be images. Collision of the bullets will come at a later point.
I also want a dodge mechanic that gives the player iframes and gives a small boost in speed.
I'll limit the movement of the player to the x-axis to keep things simple.
Implementation of the y-axis is an option, but it'll probably be included.
I want movement through the keyboard, but experimenting with the mouse is a bonus.
If those things are implemented, we'll call the player finished.

I just noticed that I didn't push the pygame_init. I'll just skip the part called level, and start with the player as 1.player.

#4
--
I've set up some basic movement, but I encountered the behaviour again where e.g. pressing both up and right results in a diagonal
movement with a speed of sqrt(2). To bypass this behaviour we can normalize with a vector. 
We use the keys to input direction. The direction is given to the method move, which combines the direction with a magnitude.
The resulting vector will be used to adjust the player position.

I've copied some code from the Zelda tut. I have some superfluous variables that give a status. This might be used to manipulate a 
sprite later in development, but for now it's just clutter, so I'll remove it.

#5
--
Removed a devlog while restoring through git...
What I've been trying to setup is a function to dodgeroll the player.
I've tried calling the dodgeroll through a decorator that handles the cooldown, since I'll use more cooldown timers.
The problem with using a decorator is that I want to stop the fuction after a certain amount of time,
and I don't know how to get it working. I'll experiment a bit at a later point in time.

#6
--
I've tried a bunch, but I'm drawing a blank when it comes to the cooldown decorator.
I've also tried to setup the decorator in such a way that the cooldown could be passed from the parameters of the original function.
I'm probably better off trying out pg.time.set_timer(), without the use of decorators. Or maybe I'm trying to be too fancy.
What I have now is partly based on ChatGTP, and it does seem iffy that the timer isn't actually called in decorator_test. 
I also don't like the try-except block. They can probably be used for a lot of things, but in my mind they're for handling errors, 
when you're scraping the barrel so to say. I'll look up their utility at a later point.   
I could just copy the method that the Zelda tutorial employed. It involved setting status and checking for status.
I found the employment of timers in that tutorial a bit cumbersome is all, so I'll try some stuff tomorrow.
I'll upload the files that I used for testing, remove them, and try again.

--
2023-03-21
#1
--
Removed a devlog again after restoring through git... Something about asses and rocks.
I've played around with some features in pygame to get signals or events. 
I've put the experiments in scrapfromtest, just for reference.
event_test.py is the most succesful version. I could run a function continuously and toggle their activity through atributes.
The decorator part didn't quite work as of yet.
I've discovered through wiki that working with signals and events are seperate programming paradigms, differing from functional or OOP. Exciting!

#2
--
When testing out the pg.event.get() method to grab the USEREVENT we get a latency of 0.1s. I wonder if this gets worse when more events
are in the queue. I also don't to what extent the display is updated through events. Window-events are mentioned in the pygame docs,
so my bet is that we'll get more latency issues as sprites are moving about. We'll see when we get there.

#3
--
Using pg.event.get() doesn't work for dodgeroll(). At least now with current setup.
I've set it up in such a way that pressing LCTRL sets self.status to 'rolling' runs self.dodgeroll().
dodgeroll() starts a timer checks if status is rolling. I can do this in two ways which results in different behaviours.
If I choose the while self.status = 'rolling', we look through events with pg.event.get(). While doing so, the player freezes untill
event.type == cooldown is found. This is not what I want.
If I choose the if self.status = 'rolling' we can control the player and notice that we do get the speed boost. However, the event.type
for cooldown won't be found, and the player never exits the rolling state.
A lot of trouble for finding another way to execute timers, and it's starting to look like every attempt so far only makes the code
more intricate, which is the opposite of what I wanted.

#4
--
Let's recap. I'm trying to modify an attribute of a class for a duration of time using events from pygame.
event_test worked, but it didn't run within the pygame setup I'm using for games. The event system should work tho, even 
in those settings. I'll create a test by copying from a previous version of SpaceFighter, and see if I can get anything to work
using events.

#5
--
I'm done with the timer. I couldn't get it to work through pg.event.
I can set the attribute of an object to status rolling when rolling, which should boost my speed.
I create a USEREVENT called cooldown, which is sent by pg.time.set_timer(cooldown, 1000).
If I use 'while self.status == 'rolling': for event in pg.event.get()' the program finds the event, 
but I'm locked out of my controls for the duration.
If I use 'if self.status=='rolling'' the program doesn't find the event, which makes sense since it's not continually scanning.
If I make a combination of the two, the locking out becomes a problem.

If I'm understanding the pygame docs correctly the event queue will wait until the specified event has passed, 
and continues when pg.event.get() returns something. Using pump() at several places didn't change the behaviour of the program.
Using pg.event.wait() didn't change the behaviour. It might work when implemented in the thread that calls display (whatever that 
means exactly), but moving the player controls to main seems dubious.

I don't feel much the wiser about event handling in pygame. Using it for a timer didn't work, which leaves me questioning the
utility of a set_timer if the program stops working while the timer is running. Maybe I need to code certain behaviours for the event,
but the pg docs aren't all that clear about it. Using Google didn't work. It's been a frustrating nightmare. Why are events so 
hard to handle in an environment made for games? Shouldn't there be an easy function for sending signals after a certain amount of time?

I guess I'll just start copying the timer setup from the Zelda tutorial, because I don't want to be bogged down any longer. 
I still think it's really cool to be delving into this kind of programming. I've learned today that signal programming and 
event-driven programming are their own programming paradigms, which I think is totally fascinating.
I'll check the signal module in Python, and maybe asyncio could do something for me here. Until then I'm just gonna borrow the 
cooldowns from Zelda.

#7
--
Did a hard reset to an older git version, and I did remember to copy the devlog this time.
There might be a way to exclude the devlog from changes but upload it anyway.

I'm just gonna code like I'm drunk for the implementation of the player, enemies, and bullets. Let's get something done.

I found one mention of async functions in pygame on stackoverflow. The solution that was opted is threading.
This sounds really cool.
Another solution might be with the python modules signal and time.
A third solution might be with asyncio, as mentioned. But it sounds kind of daunting and overkill. More like something you'd want to use
when running a server. We'll see.
I'll probably experiment with all three of them.

#8
--
As expected, Git didn't want to update my branch, because the current version is a previous version of the repository.
So I used --force, and it deleted all the commits on GitHub as well... The more you know.
Guess it's just as easy to be messy with the branches, and call it 1.1.player, I guess. 
Just a whole bunch of dead branches all over the place. Sounds kind of silly.

#9
--
Created a temporary branch for the bullets. I'll add devlog here, and set devlog in .gitignore for the other branch. 
Merging them shouldn't be a problem then. Let's test that with a new branch tho.  
Tested it, and it worked. I'll have to set .gitignore with the new branch, and again after merging, since the .gitignore from
the experimental branch overrides the original.

The bullets aren't working. The idea is to spawn bullets when pressing down the spacebar, but what happens now is that one 
sprite is spawned at initialization, and the program crashes when pressing space. I tried to spawn bullets by calling the Bullet class
through a method in Player. The problem is Bullet isn't loaded into the player, so I'm not sure how to execute the spawning of the bullets.

I might recreate the setup in Level to have drawing of bullets be executed in the Player class.
It's a bit messy. I'm taking a break.

Also, I had to add bullets.py to .gitignore. I found myself playing with the code, and now Git wants to add it to the branch.
I'll just keep the file in my folder, because it seems okay. More like I'll have to find the right way to call it.

#10
--
I couldn't help myself, and tried the idea to draw bullets to display from the Player class.
It worked like a charm. We've got a moving red rectangle that generates white rectangles. Incl. dodgerolls.

Next up is generating some enemies.

--
2023-03-22
#1
--
Moved the spawning of bullets to the level, so we don't get messy with trying to combine several lists of visible_sprites.
I already tried something like that, importing bullet sprites from player to level, 
but I keep getting errors for trying to import a None type. 
I don't really know what's happening there. I'm quickly learning that if I can avoid using the built-in pygame features I probably should.
My guess is that stuff is happening in pygame with data strutures that I poorly understand. Maybe they're custom, I'm not entirely sure.
I could use some print debugging more often to be sure, but I mostly end up with stuff like Group.object which isn't illuminating to me
for the moment. I guess I could start reading the code of pygame and try to understand what's happenig there, but it seems like a lot of
work that doesn't translate into immediate gains. I'd rather just focus on building some fun stuff for now. I'll go back to analysing things
in a day or two. Might check out that threading thing then.

Let's do some actual enemy generation.

#2
--
We have one enemy printed on screen. That's technically some enemy generation.
From the top of my head we need three components to the enemies.
We need some behaviour to put them on screen. Then we need two behaviours when they're on screen, movement and shooting.
That's two timers, and one algorithm for movement.

I guess it makes sense to implement movement first. No point in spawning them when they don't do stuff.
I'll go with the simplest movement; just an x-direction and speed.
Here's an idea for the future tho. I'll create a list or dict, and move the index by a small amount with time or number of enemies killed. 
Whenever we enter the threshold into a new index we can change movement. 
I could try adjusting the movement by manipulating the direction with trigonometry to have it be wavey, 
or follow the trajectory of a quadratic.

Another question that I'm asking myself is whether or not I want the program to be deterministic.
I think I do, to prevent situations that are completely unfair. On the other hand, it might become boring really quick if
everything is predetermined. We'll see when we get to the creation of bullets.

#3
-- 
I created a bouncy move, which lets the enemy bounce from wall to wall. I also created a line move, which moves the player from
right to left. I want to create an enemy generator that spawns the enemies after a certain amount of time.
I've been messing around with this enemy generator, and I'm currently using a counter from the standard library. It's kinda messy again.
I'll get back to it after dinner. I think I already know what I'm overcomplicating.
Note: time.sleep() doesn't work, since it freezes the whole program. 

#4
--
Created a timer with modulo. I kinda assumed it was a bit too heavy on the memory, like being afraid of an overflow somewhere. But it
works, afaik. This is driving the spawning of enemies.
I had some trouble with enemies being generated in bursts, so before te program could detect that I wanted to turn generation off it'd
already create a bunch. Using modulo and a switch removed that problem.
In the original setup I used the standard library time. I assume it works better than pygame's timer. I thought it gave a more precise output
while messing around with it. Can't be 100% sure. To keep with the theme I switched to pygame's timer. I think it's the switch that 
prevents the spamming of enemies, so it's all good. Checking with a print debugger shows just one enemy spawning and dying at every interval.

Last step for the enemies is the spawning of bullets. I think I'd like to create two seperate classes for player and enemy bullets, 
so we don't accidentally shoot ourselves. After that it's probably an idea to setup collision detection.

#5
--
Added enemy bullets, and finished the section of enemy generation.
The implementation of bullets is pretty wild.
The EnemyBullet class inherits from Bullet. The only change we make is the direction, which is the same as the players, but in the
opposite direction.
Wihin enemies I setup a switch, which is used in the generation of enemy bullets. 
The switch checks only at a certain interal (pg.time.get_ticks()/100 % 2). If the switch is False, enemy_fire is halted.
This switch is the product of trial and error, and was a left-over in the code. In practice it serves to give a bit prettier behaviour
in enemy_fire, since we don't allow for short bursts to be too dense. It takes some of the edges off.

Bullet generation is done from the Level class. I've created a seperate sprite.Group called enemy_sprites.
When generating enemy_fire() I check for enemy in enemy_sprites. Upon execution a timer is assigned to each enemy.
Within the enemy_fire() method we have it's own switch which is connected to the timer. 
We add some randomness in the conditions for the switch, so each enemy has it's own probability of generating a bullet.
If both the switch in empty_fire and the Enemy object are satisfied, a bullet will spawn. 

I'm not a 100% sure on how this works. I can edit the randomness, but editing the timing is a bit finnicky.
Working with modulo isn't that intuitive to me. The timers differ in their sensitivity (say, pg.time.get_ticks()/1, /10, or /100).
Changig the sensitivity changes the behaviour.
Then we have the modulo itself. Increasing this number slows the generation. I'm unsure what, if anything, happens when inputting decimals.
I tried inputting decimals, but my setup is so weird it's hard to draw conclusions.

These behaviours in interacting switches are kind of unpredictable to me. 
And I feel like this whole things isn't working all that consistently. This whole setup is borne out of inaccuracies when requesting
timers. A timer would register its trigger condition for too long if the setup is too precise, but miss it's trigger condition when 
moving too fast. E.g., get_ticks() % 2 registering seems purely random, since the timeunits are too small to be read processed correctly.
I remember asking myself if I wanted a determistic setup... Yeah, about that.

If I remove the deliberate randomness I can get pretty consistent behaviour tho. 
Since I'm setting the modulo condition to be equal to anything I'd want, I could have one setup that acts consistently with a 
modulo of number n, and that would give me n different actions to plan within that setup. This could provide some pretty interesting
bullet patterns.  

A pretty neat idea would be to add stuff like giving different directions to bullets, with some enemies firing at the player, 
or bullets having properties like ricochet against the boundaries. Or wavey patterns. So many options opening up. Pretty cool.

#6
--
When implementing collision I want to be able to turn it off easily, so I can continue testing bullet and spawn patterns.
I can write all collision checks in one function maybe, and simply turn it off in update method of Level.

On another note. I just heard about implementing wave function collapse in procedural generation. The creator of Bad North,
Oskar Stalberg, has done some work on that (https://oskarstalbreg.com/game/wave/wave.html). Here's the original implementation of 
WFC on GitHub (https://github.com/mxgmn/WaveFunctionCollapse).

#7
--
Making nice progress. Finished collisions. Created a cooldown system in level, basically same as in Zelda.
It's nice to have two seperate timer systems. Let's call them the modulo and the cooldown type timers.
The modulo would be nice for expanding enemy spawning, which could be rather tedious to do through cooldown timers.
It might be possible to create a small library of modulo settings. I could expand level to have three enemy generators, set them
to None by default, and according to requirements load a modulo setting into the generator. Combine that with a library of trajectories,
and we have a nice way to create a diverse set of challenges. Rather, I'd have a combat state for enemies, so we can have multiple bullets
which take from a library. I'll have to think of a way to abstract away from this one specific instance... 

Do I want to create multiple enemy types? For the moment not really. Let's have everything working on 1 hp.
So I could do with one enemy class, that accepts different states. The state that's given to an object is determined by a more
overall game state, like a difficulty setting that increases over time. I'll have the difficulty setting in level, since that's where all
the object are created. The different states can be in their own file, or in settings. The arguments for Enemy will have to be 
expanded to accept this combat state. The code that creates the different combat states will be independent from the settings for 
spawning behaviour, but both will be determined by difficulty settings. This sounds like it should work.

Before we can get into this upscaling we'll have to create different bullet trajectories, combat modes and spawning patterns.
Let's start with some bullet trajectories.

--
2023-03-23
#1
--
I created a wavey pattern. It looks okay-ish. First thing I'll do is upgrade it with a second stream of bullets that use the cos instead
of sin, so we get a prettier pattern.
It'll be a good excersize to test out how the creation of multiple bullets at once will work, and how I'll store the patterns. Rewriting 
the trajectory method and having a ton of seperate methods for every pattern is something I'd like to avoid.

#2
--
Seems like I can create multiple bullets. Combat mode for player is changed through an attribute. I'll add some power-up sprites in
the future that change this combat mode.
To make bullets have a wavey trajectory I'll need to create different Bullet classes, since bullets themselves aren't updated in the
Level class. The initial direction and number of bullets can be set in Level. It's gonna make for an unwieldy shoot_stuff() method,
but it works.

#3
--
Added some more player fire patterns. I know have a total of 6. The first three consist of lines, with the third firing with an angle.
The latter three consist of two bullets that move according to a sine function. They're wavey, giving them a bigger area of effect,
and looking nice.

Experimented a bit with adding more enemy spawn patterns. A row moving from left to right has been added. These extra enemies
turn the game from a boring side scroller into an actual bullet hell. When testing the prototype I feel my gamer credentials
basically getting nullified. Pretty amazing how fast this thing is turning into something that's actually fun to play.

I think I've got some feeling for how to further enemy spawning. To set patterns of enemies appearing we'll have to code in the
spawn_enemies() method in level. A timer is already present, so I could use that to set ramp up the difficulty in spawn patterns.
When writing spawn patterns I'll have to specify the groups that the sprite is a member off, so I could create some extra groups to
set which attack patterns the enemies get during a certain wave.

I'll probably have to create some protocol with pen and paper to have an algorithm for myself that
ensures all the proper parts are created when designing a particular wave. It's a bit unwieldy, but not overly so.
I think I'm able to work with this, and create some cool wave patterns.

#4
--
Before we add more complex spawning patterns we need to know the dimensions of the screen. 
The screen should be mostly vertical. Some remaining area on the sides can be used for interface,
like hi-score, active power-ups, or timers.

Maybe there are two ideas that I should focus on, both related to enemy movement.
First off, it should be easy to calculate positions using acceleration. Instead of thinking about describing quadratic movement
through a function, I could wing it a bit and give enemies an entry with positive velocity but negative acceleration. With timers I could 
have enemies move into frame, do a bit, and leave again. Checking for self.speed in range (0.1, -0.1) could catch when to stop, and a timer
could activate speed / acceleration again.
Another idea for movement would be through parametric equations. It'd be nice to have enemies circle and stuff. Iirc, you need a formula
for both x and y, which yields a unique solution to provide a path.

I'll move on to the next branch, which makes 4.enemy_patterns a bit of a misnomer. I see Git allows for renaming, so let's try that.
It should be 4.basic bullet patterns. The next part will be creating the right dimension. Let's tag on a start, game over screen and 
high score. I might also take a look at buttons and mouse controls. Mouse controls won't be part of the game, but it might be a nice touch
when implementing UI. I think this part is a bit more of grind to setup, but having concrete dimensions and some variables that work nicely 
when implementing enemy movement will be a boon moving along.

One important thing to setup before starting to plan waves is a sheet where the movements are planned. Could be an external document with
pseudo-code, but even nicer would be something like settings.py containing a counter that controls all switches with regard to enemy 
and power-up generation.

--
2023-03-24
#1
--
Created dimensions that feel nice. Adjusted player and enemy size.
UI is created in ui.py and rendered in Level. Additions, like the game over screen, will be created here.
We already have a player_alive attribute, so I'd best remember to use that.

The enemies are visible when exiting the borders. The solution would be a YSortCamera.
The YSort is the next thing I'll create. After that, let's create a rudimentary score and the game over screen so I don't
have to restart the program every time I die.

#2
--
Adjusted player, enemy and bullet speed. This feels more playable. I can't wait to have wave patterns so I can get back to
the non-random enemy bullets. Let's also create some borders for the player real quick.

Borders done. I also wanted to implement a smaller hitbox for the player. Not sure if I should do so right now, since I kinda
want to create a sprite for the player. No point in optimizing something that's going to be replaced regardless.

Didn't need YSortCamera to fix the border issue. Just draw the ui later instead of earlier.

#3
--
I'm a bit scatterbrained right now. I'm still working on the implementation of nice circular motion. I guess getting a grip on the motion
and timers is as important as anything else. I thought about opening a second branch, one in which I work with motions, the other for UI.
I'll just keep this in the current branch tho.

What I'm trying to do is starting the circular motion after 0.1 seconds, so the enemy gets loaded in at the correct location.
This means working the details of movement into level, since that's where the enemies are updated.
To know when to start the movement I've created an attribute in Enemy that holds the time when spawned. This requires an additional
parameter in Enemy, since we want to keep feed the time from Level into the attribute.
We'll need a seperate timer to start the motion.

#4
--
I managed to move the circular motion to level, where I gave it a timer. It didn't fix the problem, but it allowed me to observe
the start of the motion. What I think is happening is that the circular motion starts when cos(t) is at a random point, which the code
handles as y = 0. So if cos(t) = -1, the enemy starts their motion from -1 and moves up 2 units.
One way to fix this is to set the enemy spawn timers to corresponding intervals, which I think would be multiples of pi.
Or, if I set the the speed of circular motion to units of pi, wouldn't that work as well? Let's give it a try.

#5
--
It didn't work, so I used git restore . because things were getting messy. I've lost the migration of the circular motion to 
Level. I'm not even sure if I wanted it there.

Actually, I might've lost some really useful code. I might want to move enemy movement to level, because there I can create a variable 
which is the program time - time of enemy spawn, which allows me for each enemy to have their own person timer counting from 0, which
is exactly what I want for maintaining the y spawn position. It's starting to look like I'll have to move almost all methods from enemies
into level to describe enemy behaviour in time, reducing the Class to a switchboard. Maybe there's a more efficient way, tho. I could write 
a very big Enemy class, and have Level call methods from the class at certain times. So maybe I could write in Level to execute
enemy.line_move() and enemy.circle_move(), having them run at the same time, creating composite motion. That would be insanely useful.
I'll have Level be a switchboard to Enemy, which sounds like a logical thing to do. Level can keep track of the difference between 
enemy.spawn_time and get_ticks(), and when detecting certain differences call methods.

Now that I theoretically have the system with which I want to describe enemy motion, I'll still need a way to input variations 
in Enemy spawning location. One way to do it would be through a dictionary where the index is moved through time. A way better idea is to
manually set a time in Level, and call for each enemy the relevant parameters. If we have two groups on screen with differing sets 
of instructions we can use the Group system to add an extra ID. This means some boilerplate, because we'll have to manually call each
enemy. I was already thinking about abstracting the enemy creation in some way, but what we have now is probably 
complicated enough to implement.

I've included some code that shows composite movement. I've also removed the EnemyFromLeft, and set speed to be a parameter.
Let's implement a game over screen real fast.

#6
--
Still messing with the code. Still no game over screen... Expert level procrastination.
I'm thinking to make direction a parameter as well. I think I might want to. Let's try to get a enemies spawning at a high Y value and 
make a diagonal to exit somewhere on top of the screen. Let's first push to git before I break stuff again. 