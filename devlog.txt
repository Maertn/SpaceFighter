2023-03-20
#01
--
Got a working setup, with a venv and a link to GitHub.
I've created a main.py where the class Game is constructed and run.
In Game we initialize pygame. We call an attribute self.screen which calls a display from pygame.
The display requires width and height, which we store in settings.py.
We also give Game a way to shut down, which is handy if you don't want to reboot the PC everytime Game is called.

We've called self.screen.fill('black'), but when testing it doesn't do anything.
Let's keep it as a placeholder for the procedures that actually display images.
We also preemptively call display.update(). 
Leaving the parameters blank makes this method redraw everything on the screen. 
It works the same as flip(), but update() doesn't support OpenGL. 
update() can take parameters that specify which surfaces are to be updated. 
update() could be used as a more efficient way to draw if certain surfaces don't have to be updated.
I'm not sure if SF will contain any surfaces that don't update, so I'm not sure if I'll be able to exploit this feature.
I'll just keep it like this for now. 
The pygame docs state that it's better to use one update() that renders a list of all the rects, instead of several update() that renders
partial lists. Guess that calling display.update() once will suffice.

Next step we'll create a player.

#2
--
I managed to draw a surface representing our player. It's a red surface of 64*64.
I've already setup a rectangle corresponding to the player.
Let's implement some movement options next.

I've chosen to stick with the layout as presented in the Zelda tutorial, where main calls a level.
Within level we take care of initializing pygame and creating the display. Everything that is to be displayed is managed from level.
Within the level is contained the call to a player, which in turn is from the Player class in player.py.
The Player inherits from the pygame class Sprite, which gives us an easy way to manage properties,
like rendering and collision, through it's groups.
The rendering is done within the level. The classes implemented in the level are to be setup in such a way that they
can be integrated to the level environment, e.g. assigning a groups parameter that allows Level to execute the class according to 
specifications per group.

#3
--
Let's make some rules regarding the process.
I'll create some challenges for each block. We're currently in the 1.level branch, because I copied the start from the Zelda tutorial.
Going by the standards of the Zelda tut I should be done with the level, since I created the structure that allows level to accept
classes.

Next step will be the player. I'll skip the skin for now. So all we need is player movement.
Regarding player I'll also want to implement an attack. The attack needs to spawn bullets.
The bullets spawned will just be images. Collision of the bullets will come at a later point.
I also want a dodge mechanic that gives the player iframes and gives a small boost in speed.
I'll limit the movement of the player to the x-axis to keep things simple.
Implementation of the y-axis is an option, but it'll probably be included.
I want movement through the keyboard, but experimenting with the mouse is a bonus.
If those things are implemented, we'll call the player finished.

I just noticed that I didn't push the pygame_init. I'll just skip the part called level, and start with the player as 1.player.

#4
--
I've set up some basic movement, but I encountered the behaviour again where e.g. pressing both up and right results in a diagonal
movement with a speed of sqrt(2). To bypass this behaviour we can normalize with a vector. 
We use the keys to input direction. The direction is given to the method move, which combines the direction with a magnitude.
The resulting vector will be used to adjust the player position.

I've copied some code from the Zelda tut. I have some superfluous variables that give a status. This might be used to manipulate a 
sprite later in development, but for now it's just clutter, so I'll remove it.

#5
--
Removed a devlog while restoring through git...
What I've been trying to setup is a function to dodgeroll the player.
I've tried calling the dodgeroll through a decorator that handles the cooldown, since I'll use more cooldown timers.
The problem with using a decorator is that I want to stop the fuction after a certain amount of time,
and I don't know how to get it working. I'll experiment a bit at a later point in time.

#6
--
I've tried a bunch, but I'm drawing a blank when it comes to the cooldown decorator.
I've also tried to setup the decorator in such a way that the cooldown could be passed from the parameters of the original function.
I'm probably better off trying out pg.time.set_timer(), without the use of decorators. Or maybe I'm trying to be too fancy.
What I have now is partly based on ChatGTP, and it does seem iffy that the timer isn't actually called in decorator_test. 
I also don't like the try-except block. They can probably be used for a lot of things, but in my mind they're for handling errors, 
when you're scraping the barrel so to say. I'll look up their utility at a later point.   
I could just copy the method that the Zelda tutorial employed. It involved setting status and checking for status.
I found the employment of timers in that tutorial a bit cumbersome is all, so I'll try some stuff tomorrow.
I'll upload the files that I used for testing, remove them, and try again.

--
2023-03-21
#1
--
Removed a devlog again after restoring through git... Something about asses and rocks.
I've played around with some features in pygame to get signals or events. 
I've put the experiments in scrapfromtest, just for reference.
event_test.py is the most succesful version. I could run a function continuously and toggle their activity through atributes.
The decorator part didn't quite work as of yet.
I've discovered through wiki that working with signals and events are seperate programming paradigms, differing from functional or OOP. Exciting!

#2
--
When testing out the pg.event.get() method to grab the USEREVENT we get a latency of 0.1s. I wonder if this gets worse when more events
are in the queue. I also don't to what extent the display is updated through events. Window-events are mentioned in the pygame docs,
so my bet is that we'll get more latency issues as sprites are moving about. We'll see when we get there.

#3
--
Using pg.event.get() doesn't work for dodgeroll(). At least now with current setup.
I've set it up in such a way that pressing LCTRL sets self.status to 'rolling' runs self.dodgeroll().
dodgeroll() starts a timer checks if status is rolling. I can do this in two ways which results in different behaviours.
If I choose the while self.status = 'rolling', we look through events with pg.event.get(). While doing so, the player freezes untill
event.type == cooldown is found. This is not what I want.
If I choose the if self.status = 'rolling' we can control the player and notice that we do get the speed boost. However, the event.type
for cooldown won't be found, and the player never exits the rolling state.
A lot of trouble for finding another way to execute timers, and it's starting to look like every attempt so far only makes the code
more intricate, which is the opposite of what I wanted.

#4
--
Let's recap. I'm trying to modify an attribute of a class for a duration of time using events from pygame.
event_test worked, but it didn't run within the pygame setup I'm using for games. The event system should work tho, even 
in those settings. I'll create a test by copying from a previous version of SpaceFighter, and see if I can get anything to work
using events.

#5
--
I'm done with the timer. I couldn't get it to work through pg.event.
I can set the attribute of an object to status rolling when rolling, which should boost my speed.
I create a USEREVENT called cooldown, which is sent by pg.time.set_timer(cooldown, 1000).
If I use 'while self.status == 'rolling': for event in pg.event.get()' the program finds the event, 
but I'm locked out of my controls for the duration.
If I use 'if self.status=='rolling'' the program doesn't find the event, which makes sense since it's not continually scanning.
If I make a combination of the two, the locking out becomes a problem.

If I'm understanding the pygame docs correctly the event queue will wait until the specified event has passed, 
and continues when pg.event.get() returns something. Using pump() at several places didn't change the behaviour of the program.
Using pg.event.wait() didn't change the behaviour. It might work when implemented in the thread that calls display (whatever that 
means exactly), but moving the player controls to main seems dubious.

I don't feel much the wiser about event handling in pygame. Using it for a timer didn't work, which leaves me questioning the
utility of a set_timer if the program stops working while the timer is running. Maybe I need to code certain behaviours for the event,
but the pg docs aren't all that clear about it. Using Google didn't work. It's been a frustrating nightmare. Why are events so 
hard to handle in an environment made for games? Shouldn't there be an easy function for sending signals after a certain amount of time?

I guess I'll just start copying the timer setup from the Zelda tutorial, because I don't want to be bogged down any longer. 
I still think it's really cool to be delving into this kind of programming. I've learned today that signal programming and 
event-driven programming are their own programming paradigms, which I think is totally fascinating.
I'll check the signal module in Python, and maybe asyncio could do something for me here. Until then I'm just gonna borrow the 
cooldowns from Zelda.

#7
--
Did a hard reset to an older git version, and I did remember to copy the devlog this time.
There might be a way to exclude the devlog from changes but upload it anyway.

I'm just gonna code like I'm drunk for the implementation of the player, enemies, and bullets. Let's get something done.

I found one mention of async functions in pygame on stackoverflow. The solution that was opted is threading.
This sounds really cool.
Another solution might be with the python modules signal and time.
A third solution might be with asyncio, as mentioned. But it sounds kind of daunting and overkill. More like something you'd want to use
when running a server. We'll see.
I'll probably experiment with all three of them.

#8
--
As expected, Git didn't want to update my branch, because the current version is a previous version of the repository.
So I used --force, and it deleted all the commits on GitHub as well... The more you know.
Guess it's just as easy to be messy with the branches, and call it 1.1.player, I guess. 
Just a whole bunch of dead branches all over the place. Sounds kind of silly.

#9
--
Created a temporary branch for the bullets. I'll add devlog here, and set devlog in .gitignore for the other branch. 
Merging them shouldn't be a problem then. Let's test that with a new branch tho.  
Tested it, and it worked. I'll have to set .gitignore with the new branch, and again after merging, since the .gitignore from
the experimental branch overrides the original.

The bullets aren't working. The idea is to spawn bullets when pressing down the spacebar, but what happens now is that one 
sprite is spawned at initialization, and the program crashes when pressing space. I tried to spawn bullets by calling the Bullet class
through a method in Player. The problem is Bullet isn't loaded into the player, so I'm not sure how to execute the spawning of the bullets.

I might recreate the setup in Level to have drawing of bullets be executed in the Player class.
It's a bit messy. I'm taking a break.

Also, I had to add bullets.py to .gitignore. I found myself playing with the code, and now Git wants to add it to the branch.
I'll just keep the file in my folder, because it seems okay. More like I'll have to find the right way to call it.

#10
--
I couldn't help myself, and tried the idea to draw bullets to display from the Player class.
It worked like a charm. We've got a moving red rectangle that generates white rectangles. Incl. dodgerolls.

Next up is generating some enemies.

--
2023-03-22
#1
--
Moved the spawning of bullets to the level, so we don't get messy with trying to combine several lists of visible_sprites.
I already tried something like that, importing bullet sprites from player to level, 
but I keep getting errors for trying to import a None type. 
I don't really know what's happening there. I'm quickly learning that if I can avoid using the built-in pygame features I probably should.
My guess is that stuff is happening in pygame with data strutures that I poorly understand. Maybe they're custom, I'm not entirely sure.
I could use some print debugging more often to be sure, but I mostly end up with stuff like Group.object which isn't illuminating to me
for the moment. I guess I could start reading the code of pygame and try to understand what's happenig there, but it seems like a lot of
work that doesn't translate into immediate gains. I'd rather just focus on building some fun stuff for now. I'll go back to analysing things
in a day or two. Might check out that threading thing then.

Let's do some actual enemy generation.

#2
--
We have one enemy printed on screen. That's technically some enemy generation.
From the top of my head we need three components to the enemies.
We need some behaviour to put them on screen. Then we need two behaviours when they're on screen, movement and shooting.
That's two timers, and one algorithm for movement.

I guess it makes sense to implement movement first. No point in spawning them when they don't do stuff.
I'll go with the simplest movement; just an x-direction and speed.
Here's an idea for the future tho. I'll create a list or dict, and move the index by a small amount with time or number of enemies killed. 
Whenever we enter the threshold into a new index we can change movement. 
I could try adjusting the movement by manipulating the direction with trigonometry to have it be wavey, 
or follow the trajectory of a quadratic.

Another question that I'm asking myself is whether or not I want the program to be deterministic.
I think I do, to prevent situations that are completely unfair. On the other hand, it might become boring really quick if
everything is predetermined. We'll see when we get to the creation of bullets.

#3
-- 
I created a bouncy move, which lets the enemy bounce from wall to wall. I also created a line move, which moves the player from
right to left. I want to create an enemy generator that spawns the enemies after a certain amount of time.
I've been messing around with this enemy generator, and I'm currently using a counter from the standard library. It's kinda messy again.
I'll get back to it after dinner. I think I already know what I'm overcomplicating.
Note: time.sleep() doesn't work, since it freezes the whole program. 

#4
--
Created a timer with modulo. I kinda assumed it was a bit too heavy on the memory, like being afraid of an overflow somewhere. But it
works, afaik. This is driving the spawning of enemies.
I had some trouble with enemies being generated in bursts, so before te program could detect that I wanted to turn generation off it'd
already create a bunch. Using modulo and a switch removed that problem.
In the original setup I used the standard library time. I assume it works better than pygame's timer. I thought it gave a more precise output
while messing around with it. Can't be 100% sure. To keep with the theme I switched to pygame's timer. I think it's the switch that 
prevents the spamming of enemies, so it's all good. Checking with a print debugger shows just one enemy spawning and dying at every interval.

Last step for the enemies is the spawning of bullets. I think I'd like to create two seperate classes for player and enemy bullets, 
so we don't accidentally shoot ourselves. After that it's probably an idea to setup collision detection.

#5
--
Added enemy bullets, and finished the section of enemy generation.
The implementation of bullets is pretty wild.
The EnemyBullet class inherits from Bullet. The only change we make is the direction, which is the same as the players, but in the
opposite direction.
Wihin enemies I setup a switch, which is used in the generation of enemy bullets. 
The switch checks only at a certain interal (pg.time.get_ticks()/100 % 2). If the switch is False, enemy_fire is halted.
This switch is the product of trial and error, and was a left-over in the code. In practice it serves to give a bit prettier behaviour
in enemy_fire, since we don't allow for short bursts to be too dense. It takes some of the edges off.

Bullet generation is done from the Level class. I've created a seperate sprite.Group called enemy_sprites.
When generating enemy_fire() I check for enemy in enemy_sprites. Upon execution a timer is assigned to each enemy.
Within the enemy_fire() method we have it's own switch which is connected to the timer. 
We add some randomness in the conditions for the switch, so each enemy has it's own probability of generating a bullet.
If both the switch in empty_fire and the Enemy object are satisfied, a bullet will spawn. 

I'm not a 100% sure on how this works. I can edit the randomness, but editing the timing is a bit finnicky.
Working with modulo isn't that intuitive to me. The timers differ in their sensitivity (say, pg.time.get_ticks()/1, /10, or /100).
Changig the sensitivity changes the behaviour.
Then we have the modulo itself. Increasing this number slows the generation. I'm unsure what, if anything, happens when inputting decimals.
I tried inputting decimals, but my setup is so weird it's hard to draw conclusions.

These behaviours in interacting switches are kind of unpredictable to me. 
And I feel like this whole things isn't working all that consistently. This whole setup is borne out of inaccuracies when requesting
timers. A timer would register its trigger condition for too long if the setup is too precise, but miss it's trigger condition when 
moving too fast. E.g., get_ticks() % 2 registering seems purely random, since the timeunits are too small to be read processed correctly.
I remember asking myself if I wanted a determistic setup... Yeah, about that.

If I remove the deliberate randomness I can get pretty consistent behaviour tho. 
Since I'm setting the modulo condition to be equal to anything I'd want, I could have one setup that acts consistently with a 
modulo of number n, and that would give me n different actions to plan within that setup. This could provide some pretty interesting
bullet patterns.  

A pretty neat idea would be to add stuff like giving different directions to bullets, with some enemies firing at the player, 
or bullets having properties like ricochet against the boundaries. Or wavey patterns. So many options opening up. Pretty cool.

#6
--
When implementing collision I want to be able to turn it off easily, so I can continue testing bullet and spawn patterns.
I can write all collision checks in one function maybe, and simply turn it off in update method of Level.

On another note. I just heard about implementing wave function collapse in procedural generation. The creator of Bad North,
Oskar Stalberg, has done some work on that (https://oskarstalbreg.com/game/wave/wave.html). Here's the original implementation of 
WFC on GitHub (https://github.com/mxgmn/WaveFunctionCollapse).

#7
--
Making nice progress. Finished collisions. Created a cooldown system in level, basically same as in Zelda.
It's nice to have two seperate timer systems. Let's call them the modulo and the cooldown type timers.
The modulo would be nice for expanding enemy spawning, which could be rather tedious to do through cooldown timers.
It might be possible to create a small library of modulo settings. I could expand level to have three enemy generators, set them
to None by default, and according to requirements load a modulo setting into the generator. Combine that with a library of trajectories,
and we have a nice way to create a diverse set of challenges. Rather, I'd have a combat state for enemies, so we can have multiple bullets
which take from a library. I'll have to think of a way to abstract away from this one specific instance... 

Do I want to create multiple enemy types? For the moment not really. Let's have everything working on 1 hp.
So I could do with one enemy class, that accepts different states. The state that's given to an object is determined by a more
overall game state, like a difficulty setting that increases over time. I'll have the difficulty setting in level, since that's where all
the object are created. The different states can be in their own file, or in settings. The arguments for Enemy will have to be 
expanded to accept this combat state. The code that creates the different combat states will be independent from the settings for 
spawning behaviour, but both will be determined by difficulty settings. This sounds like it should work.

Before we can get into this upscaling we'll have to create different bullet trajectories, combat modes and spawning patterns.
Let's start with some bullet trajectories.
