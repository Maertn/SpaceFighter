2023-03-20
#01
--
Got a working setup, with a venv and a link to GitHub.
I've created a main.py where the class Game is constructed and run.
In Game we initialize pygame. We call an attribute self.screen which calls a display from pygame.
The display requires width and height, which we store in settings.py.
We also give Game a way to shut down, which is handy if you don't want to reboot the PC everytime Game is called.

We've called self.screen.fill('black'), but when testing it doesn't do anything.
Let's keep it as a placeholder for the procedures that actually display images.
We also preemptively call display.update(). 
Leaving the parameters blank makes this method redraw everything on the screen. 
It works the same as flip(), but update() doesn't support OpenGL. 
update() can take parameters that specify which surfaces are to be updated. 
update() could be used as a more efficient way to draw if certain surfaces don't have to be updated.
I'm not sure if SF will contain any surfaces that don't update, so I'm not sure if I'll be able to exploit this feature.
I'll just keep it like this for now. 
The pygame docs state that it's better to use one update() that renders a list of all the rects, instead of several update() that renders
partial lists. Guess that calling display.update() once will suffice.

Next step we'll create a player.

#2
--
I managed to draw a surface representing our player. It's a red surface of 64*64.
I've already setup a rectangle corresponding to the player.
Let's implement some movement options next.

I've chosen to stick with the layout as presented in the Zelda tutorial, where main calls a level.
Within level we take care of initializing pygame and creating the display. Everything that is to be displayed is managed from level.
Within the level is contained the call to a player, which in turn is from the Player class in player.py.
The Player inherits from the pygame class Sprite, which gives us an easy way to manage properties,
like rendering and collision, through it's groups.
The rendering is done within the level. The classes implemented in the level are to be setup in such a way that they
can be integrated to the level environment, e.g. assigning a groups parameter that allows Level to execute the class according to 
specifications per group.

#3
--
Let's make some rules regarding the process.
I'll create some challenges for each block. We're currently in the 1.level branch, because I copied the start from the Zelda tutorial.
Going by the standards of the Zelda tut I should be done with the level, since I created the structure that allows level to accept
classes.

Next step will be the player. I'll skip the skin for now. So all we need is player movement.
Regarding player I'll also want to implement an attack. The attack needs to spawn bullets.
The bullets spawned will just be images. Collision of the bullets will come at a later point.
I also want a dodge mechanic that gives the player iframes and gives a small boost in speed.
I'll limit the movement of the player to the x-axis to keep things simple.
Implementation of the y-axis is an option, but it'll probably be included.
I want movement through the keyboard, but experimenting with the mouse is a bonus.
If those things are implemented, we'll call the player finished.

I just noticed that I didn't push the pygame_init. I'll just skip the part called level, and start with the player as 1.player.

#4
--
I've set up some basic movement, but I encountered the behaviour again where e.g. pressing both up and right results in a diagonal
movement with a speed of sqrt(2). To bypass this behaviour we can normalize with a vector. 
We use the keys to input direction. The direction is given to the method move, which combines the direction with a magnitude.
The resulting vector will be used to adjust the player position.

I've copied some code from the Zelda tut. I have some superfluous variables that give a status. This might be used to manipulate a 
sprite later in development, but for now it's just clutter, so I'll remove it.

#5
--
Removed a devlog while restoring through git...
What I've been trying to setup is a function to dodgeroll the player.
I've tried calling the dodgeroll through a decorator that handles the cooldown, since I'll use more cooldown timers.
The problem with using a decorator is that I want to stop the fuction after a certain amount of time,
and I don't know how to get it working. I'll experiment a bit at a later point in time.

#6
--
I've tried a bunch, but I'm drawing a blank when it comes to the cooldown decorator.
I've also tried to setup the decorator in such a way that the cooldown could be passed from the parameters of the original function.
I'm probably better off trying out pg.time.set_timer(), without the use of decorators. Or maybe I'm trying to be too fancy.
What I have now is partly based on ChatGTP, and it does seem iffy that the timer isn't actually called in decorator_test. 
I also don't like the try-except block. They can probably be used for a lot of things, but in my mind they're for handling errors, 
when you're scraping the barrel so to say. I'll look up their utility at a later point.   
I could just copy the method that the Zelda tutorial employed. It involved setting status and checking for status.
I found the employment of timers in that tutorial a bit cumbersome is all, so I'll try some stuff tomorrow.
I'll upload the files that I used for testing, remove them, and try again.

--
2023-03-21
#1
--
Removed a devlog again after restoring through git... Something about asses and rocks.
I've played around with some features in pygame to get signals or events. 
I've put the experiments in scrapfromtest, just for reference.
event_test.py is the most succesful version. I could run a function continuously and toggle their activity through atributes.
The decorator part didn't quite work as of yet.
I've discovered through wiki that working with signals and events are seperate programming paradigms, differing from functional or OOP. Exciting!

#2
--
When testing out the pg.event.get() method to grab the USEREVENT we get a latency of 0.1s. I wonder if this gets worse when more events
are in the queue. I also don't to what extent the display is updated through events. Window-events are mentioned in the pygame docs,
so my bet is that we'll get more latency issues as sprites are moving about. We'll see when we get there.

#3
--
Using pg.event.get() doesn't work for dodgeroll(). At least now with current setup.
I've set it up in such a way that pressing LCTRL sets self.status to 'rolling' runs self.dodgeroll().
dodgeroll() starts a timer checks if status is rolling. I can do this in two ways which results in different behaviours.
If I choose the while self.status = 'rolling', we look through events with pg.event.get(). While doing so, the player freezes untill
event.type == cooldown is found. This is not what I want.
If I choose the if self.status = 'rolling' we can control the player and notice that we do get the speed boost. However, the event.type
for cooldown won't be found, and the player never exits the rolling state.
A lot of trouble for finding another way to execute timers, and it's starting to look like every attempt so far only makes the code
more intricate, which is the opposite of what I wanted.

#4
--
Let's recap. I'm trying to modify an attribute of a class for a duration of time using events from pygame.
event_test worked, but it didn't run within the pygame setup I'm using for games. The event system should work tho, even 
in those settings. I'll create a test by copying from a previous version of SpaceFighter, and see if I can get anything to work
using events.

#5
--
I'm done with the timer. I couldn't get it to work through pg.event.
I can set the attribute of an object to status rolling when rolling, which should boost my speed.
I create a USEREVENT called cooldown, which is sent by pg.time.set_timer(cooldown, 1000).
If I use 'while self.status == 'rolling': for event in pg.event.get()' the program finds the event, 
but I'm locked out of my controls for the duration.
If I use 'if self.status=='rolling'' the program doesn't find the event, which makes sense since it's not continually scanning.
If I make a combination of the two, the locking out becomes a problem.

If I'm understanding the pygame docs correctly the event queue will wait until the specified event has passed, 
and continues when pg.event.get() returns something. Using pump() at several places didn't change the behaviour of the program.
Using pg.event.wait() didn't change the behaviour. It might work when implemented in the thread that calls display (whatever that 
means exactly), but moving the player controls to main seems dubious.

I don't feel much the wiser about event handling in pygame. Using it for a timer didn't work, which leaves me questioning the
utility of a set_timer if the program stops working while the timer is running. Maybe I need to code certain behaviours for the event,
but the pg docs aren't all that clear about it. Using Google didn't work. It's been a frustrating nightmare. Why are events so 
hard to handle in an environment made for games? Shouldn't there be an easy function for sending signals after a certain amount of time?

I guess I'll just start copying the timer setup from the Zelda tutorial, because I don't want to be bogged down any longer. 
I still think it's really cool to be delving into this kind of programming. I've learned today that signal programming and 
event-driven programming are their own programming paradigms, which I think is totally fascinating.
I'll check the signal module in Python, and maybe asyncio could do something for me here. Until then I'm just gonna borrow the 
cooldowns from Zelda.

#7
--
Did a hard reset to an older git version, and I did remember to copy the devlog this time.
There might be a way to exclude the devlog from changes but upload it anyway.

I'm just gonna code like I'm drunk for the implementation of the player, enemies, and bullets. Let's get something done.

I found one mention of async functions in pygame on stackoverflow. The solution that was opted is threading.
This sounds really cool.
Another solution might be with the python modules signal and time.
A third solution might be with asyncio, as mentioned. But it sounds kind of daunting and overkill. More like something you'd want to use
when running a server. We'll see.
I'll probably experiment with all three of them.

#8
--
As expected, Git didn't want to update my branch, because the current version is a previous version of the repository.
So I used --force, and it deleted all the commits on GitHub as well... The more you know.
Guess it's just as easy to be messy with the branches, and call it 1.1.player, I guess. 
Just a whole bunch of dead branches all over the place. Sounds kind of silly.

#9
--
Created a temporary branch for the bullets. I'll add devlog here, and set devlog in .gitignore for the other branch. 
Merging them shouldn't be a problem then. Let's test that with a new branch tho.  
Tested it, and it worked. I'll have to set .gitignore with the new branch, and again after merging, since the .gitignore from
the experimental branch overrides the original.

The bullets aren't working. The idea is to spawn bullets when pressing down the spacebar, but what happens now is that one 
sprite is spawned at initialization, and the program crashes when pressing space. I tried to spawn bullets by calling the Bullet class
through a method in Player. The problem is Bullet isn't loaded into the player, so I'm not sure how to execute the spawning of the bullets.

I might recreate the setup in Level to have drawing of bullets be executed in the Player class.
It's a bit messy. I'm taking a break.

Also, I had to add bullets.py to .gitignore. I found myself playing with the code, and now Git wants to add it to the branch.
I'll just keep the file in my folder, because it seems okay. More like I'll have to find the right way to call it.

#10
--
I couldn't help myself, and tried the idea to draw bullets to display from the Player class.
It worked like a charm. We've got a moving red rectangle that generates white rectangles. Incl. dodgerolls.

Next up is generating some enemies.

--
2023-03-22
#1
--
Moved the spawning of bullets to the level, so we don't get messy with trying to combine several lists of visible_sprites.
I already tried something like that, importing bullet sprites from player to level, 
but I keep getting errors for trying to import a None type. 
I don't really know what's happening there. I'm quickly learning that if I can avoid using the built-in pygame features I probably should.
My guess is that stuff is happening in pygame with data strutures that I poorly understand. Maybe they're custom, I'm not entirely sure.
I could use some print debugging more often to be sure, but I mostly end up with stuff like Group.object which isn't illuminating to me
for the moment. I guess I could start reading the code of pygame and try to understand what's happenig there, but it seems like a lot of
work that doesn't translate into immediate gains. I'd rather just focus on building some fun stuff for now. I'll go back to analysing things
in a day or two. Might check out that threading thing then.

Let's do some actual enemy generation.

#2
--
We have one enemy printed on screen. That's technically some enemy generation.
From the top of my head we need three components to the enemies.
We need some behaviour to put them on screen. Then we need two behaviours when they're on screen, movement and shooting.
That's two timers, and one algorithm for movement.

I guess it makes sense to implement movement first. No point in spawning them when they don't do stuff.
I'll go with the simplest movement; just an x-direction and speed.
Here's an idea for the future tho. I'll create a list or dict, and move the index by a small amount with time or number of enemies killed. 
Whenever we enter the threshold into a new index we can change movement. 
I could try adjusting the movement by manipulating the direction with trigonometry to have it be wavey, 
or follow the trajectory of a quadratic.

Another question that I'm asking myself is whether or not I want the program to be deterministic.
I think I do, to prevent situations that are completely unfair. On the other hand, it might become boring really quick if
everything is predetermined. We'll see when we get to the creation of bullets.